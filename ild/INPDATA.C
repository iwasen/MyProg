/************************************************************************
 *									*
 *		統合光波表示装置　Ｓ／Ｇ　ＣＰＵプログラム		*
 *									*
 *		名称		: 入力データ処理			*
 *		ファイル名	: inpdata.c				*
 *									*
 ************************************************************************/
#pragma	SECTION PROG=inpdata

#include "sg_cpu.h"

/*	入力データチェックテーブル	*/
static	short	data_check_tbl1[][2] = {
	{-51, 300},		/*  0 速度 */
	{-1001, 15000},		/*  1 高度 */
	{0, 3599},		/*  2 機首方位 */
	{-4500, 4500},		/*  3 ピッチ */
	{-9000, 9000},		/*  4 ロール */
	{-18000, 18000},	/*  5 センサＬＯＳ（アジマス値） */
	{-6000, 6000},		/*  6 センサＬＯＳ（エレベーション値） */
	{0, 9000},		/*  7 センサＦＯＶ */
	{-422, 423},		/*  8 レーザー照射点（Ｘ座標） */
	{-422, 423},		/*  9 レーザー照射点（Ｙ座標） */
	{0, 2},			/* 10 レーザー照射ステータス */
	{-32768, 32767},	/* 11 レーザーコード */
	{0, 3},			/* 12 レーザー照射モード */
	{0, 9995},		/* 13 レーザー測距結果（最近点） */
	{0, 9995},		/* 14 レーザー測距結果（最遠点） */
	{0, 3},			/* 15 センサ画像 */
	{0, 4},			/* 16 追尾ゲートの種類 */
	{0, 845},		/* 17 追尾ゲートの位置（Ｘ座標） */
	{0, 845},		/* 18 追尾ゲートの位置（Ｙ座標） */
	{0, 845},		/* 19 追尾ゲートのサイズ（横幅） */
	{0, 845},		/* 20 追尾ゲートのサイズ（高さ） */
	{0, 3},			/* 21 索敵サイトシンボルのサブモード */
	{0, 8},			/* 22 メッセージ１（空間安定モード） */
	{0, 2},			/* 23 メッセージ２（追尾方式） */
	{0, 2},			/* 24 メッセージ３（ＦＬＩＲ時の表示極性） */
	{0, 3},			/* 25 メッセージ４（ズーム速度） */
	{0, 1},			/* 26 レーザーオフ指令 */
	{0, 1},			/* 27 ウォーニング１（レーザー照射部制御） */
	{0, 1},			/* 28 ウォーニング２（空間安定装置制御部） */
	{0, 2},			/* 29 ミサイルの有無 */
	{-18000, 18000},	/* 30 ミサイルの位置（アジマス値） */
	{-8999, 8999},		/* 31 ミサイルの位置（エレベーション値） */
	{0, 845},		/* 32 ＩＦＦゲート１の位置（アジマス値） */
	{0, 845},		/* 33 ＩＦＦゲート１の位置(エレベーション値)*/
	{0, 2},			/* 34 ＩＦＦゲート１の識別結果 */
	{0, 845},		/* 35 ＩＦＦゲート２のサイズ */
	{0, 845},		/* 36 ＩＦＦゲート２の位置（アジマス値） */
	{0, 845},		/* 37 ＩＦＦゲート２の位置(エレベーション値)*/
	{0, 2},			/* 38 ＩＦＦゲート２の識別結果 */
	{0, 845},		/* 39 ＩＦＦゲート２のサイズ */
	{0, 845},		/* 40 ＩＦＦゲート３の位置（アジマス値） */
	{0, 845},		/* 41 ＩＦＦゲート３の位置(エレベーション値)*/
	{0, 2},			/* 42 ＩＦＦゲート３の識別結果 */
	{0, 845},		/* 43 ＩＦＦゲート３のサイズ */
	{0, 1},			/* 44 障害物の有無 */
	{0, 999}		/* 45 障害物までの最短距離 */
};
static	short	data_check_tbl2[][2] = {
	{-18000, 18000},	/* (46) 障害物Ｘの位置（アジマス値） */
	{-8999, 8999},		/* (47) 障害物Ｘの位置（エレベーション値） */
	{0, 999}		/* (48) 障害物Ｘまでの距離 */
};
static	short	data_check_tbl3[][2] = {
	{0, 2},			/* 346 ビデオ表示モードの切り換え */
	{0, 3},			/* 347 テストパターン */
	{0, 1},			/* 348 ＢＩＴ開始指令 */
	{0, 1},			/* 349 ＣＲＴモニタ表示画像の切り換え */
	{-1, 23},		/* 350 時刻（時） */
	{-1, 59},		/* 351 時刻（分） */
	{-1, 59},		/* 352 時刻（秒） */
	{-32768, 32767},	/* 353 応答コード */
	{0, 999},		/* 354 しきい値１ */
	{0, 999},		/* 355 しきい値２ */
	{1, 10},		/* 356 デジタル値の更新レート */
	{-422, 423},		/* 357 ミサイルシンボル・オフセット量(Ｘ座標)*/
	{-422, 423}		/* 358 ミサイルシンボル・オフセット量(Ｙ座標)*/
};

/*	内部関数	*/
static	void	set_digital_update_speed(void);
static	void	mode_check(void);
static	void	set_video_mode(void);
static	void	bit_check(void);

/*=======================================================================
 |
 |		入力データ処理計算処理
 |
 |	void	inpdata()
 |
 =======================================================================*/
void	inpdata(void)
{
	/* パワーオン・テストパターン表示終了待ち */
	while (seq_power_on != 0)
		;

	ibuf_flag = 0;		/* 入力バッファクリア */

	/* 入力データ処理 */
	for (;;) {
		if (ibuf_flag == 0)	/* 入力データ待ち */
			continue;

		set_digital_update_speed();/* デジタル数値更新速度設定 */
		mode_check();		/* 表示モードチェック */
		set_video_mode();	/* ビデオモード設定 */
		bit_check();		/* ＢＩＴチェック処理 */
		calc_dp(1);		/* Ｄ／Ｐ計算 */
		ibuf_flag = 0;

		/* Ｄ／Ｐ，Ｐ／Ａをテンポラリエリアにコピー */
		*REG_VIC_VICR4 = 0x84;	/* ＧＳＣ描画終了割り込み禁止 */
		dp_tmp = dp;			/* Ｄ／Ｐコピー */
		COPY_WORD(pa_tmp, pa, N_PABIT);	/* Ｐ／Ａコピー */
		if (rate_gscint == 0) {
			/* Ｄ／ＰをＲＡＰにセット */
			*(DP *)ADR_RAP_DP = dp_tmp;

			/* Ｐ／ＡビットをＲＡＰにセット */
			COPY_WORD(ADR_RAP_PA, pa_tmp, N_PABIT);
		}

		*REG_VIC_VICR4 = 0x04;	/* ＧＳＣ描画終了割り込み禁止解除 */
		count_calc++;		/* for debug */
	}
}

/*=======================================================================
 |
 |		デジタル数値更新速度設定
 |
 |	void	set_digital_update_speed()
 |
 =======================================================================*/
static	void	set_digital_update_speed(void)
{
	if (input_data[356] >= 1 && input_data[356] <= 10)
		digital_update_rate = 100 / input_data[356];
	else
		digital_update_rate = 50;
}

/*=======================================================================
 |
 |		グラフィック表示モードチェック
 |
 |	void	mode_check()
 |
 =======================================================================*/
static	void	mode_check(void)
{
	if (data_check(348))
		return;

	if (input_data[348] == 1)
		sg_mode = MODE_BIT;
	else {
		if (data_check(347))
			return;

		if (input_data[347] != 0)
			sg_mode = MODE_TESTPTN;
		else {
			if (data_check(29))
				return;

			if ((input_data[29] & 0xff00) == 0x0300)
				sg_mode = MODE_MISSILE;
			else {
				if (data_check(21))
					return;

				switch (input_data[21]) {
				case 0:
					sg_mode = MODE_SAKUTEKI0;
					break;
				case 1:
					sg_mode = MODE_SAKUTEKI1;
					break;
				case 2:
					sg_mode = MODE_SAKUTEKI2;
					break;
				case 3:
					sg_mode = MODE_SAKUTEKI3;
					break;
				}
			}
		}
	}
}

/*=======================================================================
 |
 |		ビデオモードチェック
 |
 |	void	set_video_mode()
 |
 =======================================================================*/
static	void	set_video_mode(void)
{
	byte	tmp;

	tmp = 0;

	/* ＬＣＤ表示用ビデオ入力 */
	if (input_data[15] == 2 || input_data[15] == 3)
		tmp |= 0x01;

	/* ＣＲＴ表示用ビデオ入力 */
	if (input_data[349] == 1)
		tmp |= 0x02;

	/* ＬＣＤ表示映像モード */
	if (input_data[15] != 0 && (input_data[29] & 0xff00) != 0x0300 &&
				input_data[347] == 0 && input_data[348] == 0)
		tmp |= 0x04;
	else
		tmp |= 0x08;

	/* ビデオ表示モード切り換え */
	switch (input_data[346]) {
	case 1:
		tmp |= 0x10;
		break;
	case 2:
		tmp |= 0x20;
		break;
	}

	video_mode = tmp;
}

/*=======================================================================
 |
 |		ＢＩＴチェック処理
 |
 |	void	bit_check()
 |
 =======================================================================*/
static	void	bit_check(void)
{
	char	sendbuf[2];

	/* 入力データチェック */
	if (data_check(348))
		return;

	if (input_data[348] != bit_data) {	/* 変化チェック */
		/* 現データ保存 */
		bit_data = input_data[348];

		if (bit_data == 1) {
			bit_status = BIT_START;
			calc_dp(1);

			*REG_VIC_VICR4 = 0x84;	/* ＧＳＣ描画終了割り込み禁止*/
			dp_tmp = dp;			/* Ｄ／Ｐコピー */
			COPY_WORD(pa_tmp, pa, N_PABIT);	/* Ｐ／Ａコピー */
			*REG_VIC_VICR4 = 0x04;	/* ＧＳＣ描画終了割り込み禁止解除 */

			rom_check();	/* ＲＯＭチェック */
			int_disable();
			ram_check();	/* ＲＡＭチェック */
			int_enable();

			/* Ｄ／ＵからのＢＩＴ結果受信監視タイマーセット */
			tmc_dubit = 0;
			tmf_dubit = TIMER_START;
		} else {
			/* Ｄ／ＵからのＢＩＴ結果受信監視タイマー停止 */
			tmf_dubit = TIMER_STOP;
		}

		/* Ｄ／ＵへＢＩＴ開始／終了指令を送信 */
		sendbuf[0] = 'B';
		sendbuf[1] = (char)bit_data;
		rsa_send(sendbuf, 2);

	}
}

/*=======================================================================
 |
 |		入力データチェック
 |
 |	int	data_check(dno)
 |
 =======================================================================*/
int	data_check(int dno)
{
	int	error, n;
	short	high, low;

	if (dno == 27) {
		/* ウォーニング１，２ */
		high = (input_data[27] >> 8) & 0x00ff;
		low = input_data[27] & 0x00ff;
		error = (CHECK(high, 0, 1) || CHECK(low, 0, 1));
	} else if (dno == 28) {
		/* ウォーニング３，４ */
		high = (input_data[28] >> 8) & 0x00ff;
		low = input_data[28] & 0x00ff;
		error = (CHECK(high, 0, 1) || CHECK(low, 0, 1));
	} else if (dno == 29) {
		/* ミサイルシンボルの種類，ミサイル探知ステータス */
		high = (input_data[29] >> 8) & 0x00ff;
		low = input_data[29] & 0x00ff;
		error = (CHECK(high, 0, 3) || CHECK(low, 0, 1));
	}else if (dno <= 45) {
		/* ２７，２８，２９を除く番号０〜４５までのデータ */
		error = (CHECK(input_data[dno], data_check_tbl1[dno][0],
						data_check_tbl1[dno][1]));
	} else if (dno <= 345) {
		/* 障害物データ（番号４６〜３４５） */
		n = (dno - 46) % 3;
		error = (CHECK(input_data[dno], data_check_tbl2[n][0],
						data_check_tbl2[n][1]));
	} else if (dno <= 358) {
		/* 番号３４６〜３５８までのデータ */
		n = dno - 346;
		error = (CHECK(input_data[dno], data_check_tbl3[n][0],
						data_check_tbl3[n][1]));
	} else
		error = 0;

	if (error)
		data_error_flag = 1;	/* データエラーフラグセット */

	return(error);
}
